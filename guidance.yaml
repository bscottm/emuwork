# TRS-80 Model I ROM disassembly guidance
#
# Currently, only guidance for the Level II ROM is here.
---
origin: 0x0000
end: 0x2fff

Model I Level II:
- md5: ca74822ebc2803c6635a55116ecd9539
- comment: Restart vector redirections. These are 'JP' instructions
- equate:
    value: 0x4000
    name: RST08VEC
- equate:
    value: 0x4003
    name: RST10VEC
- equate:
    value: 0x4006
    name: RST18VEC
- equate:
    value: 0x4009
    name: RST20VEC
- equate:
    value: 0x400c
    name: RST28VEC
- equate:
    value: 0x400f
    name: RST30VEC
- equate:
    value: 0x4012
    name: RST38VEC
- equate:
    value: 0x4015
    name: KIDCB
- equate:
    value: 0x401c
    name: CURSBLINK
- comment: Video device control block ('DO' == Direct Output)
- equate:
    value: 0x401d
    name: DODCB
- comment: Cursor position (2 bytes, LSB/MSB)
- equate:
    value: 0x4020
    name: CSRPOS
- comment: Line printer device control block
- equate:
    value: 0x4025
    name: PRDCB
- comment: Bad DCB vector, used by OUTDCB
- equate:
    value: 0x4033
    name: BADDCBVEC
- comment: Cassette port and line printer width control byte
- comment: 0=64 char, 8=32 char.
- equate:
    value: 0x403d
    name: CASPLPRT
- comment: ! 'OSVER$: DOS version number'
- equate:
    value: 0x403e
    name: DOSVER
- comment: 25 millisecond clock count
- equate:
    value: 0x4040
    name: CLKTICK
- comment: ! 'TIME$: Time of day (seconds, minutes, hours)'
- equate:
    value: 0x4041
    name: SYSTIME
- comment: ! 'DATE$: Day of year (year, month, day)'
- equate:
    value: 0x4044
    name: SYSDATE
- comment: ! 'HIFH$: DOS highest unused RAM address'
- equate:
    value: 0x404a
    name: HIFH
- comment: ! '4080 - 41FF: Basic reserved area. L2INIRESRVD initializes this area'
- equate:
    value: 0x4080
    name: BASICRESV
- comment: USR function pointer
- equate:
    value: 0x408e
    name: USRFNPTR
- comment: INKEY$ storage
- equate:
    value: 0x4099
    name: INKEYSTO
- comment: Error code for RESUME
- equate:
    value: 0x409a
    name: RESUMEERC
- comment: Printer carriage position
- equate:
    value: 0x409b
    name: PRCURPOS
- comment: ! 'Device type flag: -1 = tape, 0 = video, 1 = line printer'
- equate:
    value: 0x409c
    name: DEVTYPEFLAG
- comment: ! 'PRINT# scratch space'
- equate:
    value: 0x409d
    name: PRNUMWORK
- comment: Pointer to lowest address available for string storage
- equate:
    value: 0x40a0
    name: STRINGLO
- comment: BASIC program line number counter, current line being processed
- equate:
    value: 0x40a2
    name: BASLINENO
- comment: Start of BASIC program pointer, first byte where BASIC programs are stored
- equate:
    value: 0x40a4
    name: BASPRGSTART
- comment: Line cursor position
- equate:
    value: 0x40a6
    name: LINECSRPOS
- comment: Input buffer pointer
- equate:
    value: 0x40a7
    name: INPBUFPTR
- comment: RND seed
- equate:
    value: 0x40aa
    name: RNDSEED
- comment: |
    NTF: Numeric Type Flag
    2: Integer
    3: String
    4: Single precision floating point
    8: Double precision floating point
    (see CPDE2HL)
- equate:
    value: 0x40af
    name: NTF
- comment: |
    Top of memory/highest memory address available for string
    storage. Memory above this address pointer is 'reserved'.
- equate:
    value: 0x40b1
    name: MEMTOP
- comment: ! 'STRWORKPTR: String work area pointer'
- equate:
    value: 0x40b3
    name: STRWORKPTR
- comment: String work area (0x40b5 - 0x40d5
- equate:
    value: 0x40b5
    name: STRWORKAREA
- comment: Pointer to next byte of string storage
- equate:
    value: 0x40d6
    name: NEXTSTRPTR
- comment: ! 'Double precision accumulator: LSB, LSB, LSB, LSB, LSB, LSB, MSB, EXP'
- equate:
    value: 0x411d
    name: DACC
- comment: ! 'Integer accumulator: LSB, MSB'
- comment: Single precision accumulator, LSB, LSB, MSB, EXP
- equate:
    value: 0x4121
    name: IACC
- comment: Most significant byte in the SP floating point number's mantissa
- equate:
    value: 0x4123
    name: SPMANT_MSB
- comment: ! '"Hex" accumulator: integer, single, double precision aligned at'
- comment: the same location.
- equate:
    value: 0x4127
    name: HEXACC
- comment: TRSDOS command vector redirections. These are also 'JP' instructions
- equate:
    value: 0x4173
    name: DOSVECCMD
- comment: |
    =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
    Memory mapped I/O addresses
    =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
- equate:
    value: 0x37e8
    name: LPPORT
- equate:
    value: 0x37ec
    name: DSKCMDSTATUS
- equate:
    value: 0x37ed
    name: DSKTRKSEL
- equate:
    value: 0x37ee
    name: DSKSECSEL
- equate:
    value: 0x37ef
    name: DSKDATA
- equate:
    value: 0x3801
    name: KBDLINE0
- equate:
    value: 0x3840
    name: KBDLINEFNKEYS
- equate:
    value: 0x3880
    name: KBDLINESHIFTS
- equate:
    value: 0x3c00
    name: VIDRAM
- equate:
    value: 0x3c3e
    name: VIDLINE0RIGHT1
- equate:
    value: 0x3c32
    name: VIDLINE0RIGHT2
- comment: |+
    =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
    TRS-80 Model I Level II ROM disassembly:
    =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=

- disasm:
    nbytes: 0x004f
    addr: 0x0000
- bytes:
    nbytes: 0x0010
    addr: 0x0050
- disasm:
    nbytes: 0x00a4
    addr: 0x0060
- ascii:
    nbytes: 0x000b
    addr: 0x0105
- bytes:
    nbytes: 0x0001
    addr: 0x0110
- ascii:
    nbytes: 0x001a
    addr: 0x0111
- bytes:
    nbytes: 0x0002
    addr: 0x012b
- disasm:
    nbytes: 0x020c
    addr: 0x012d
- comment: |
    This is an alternate entry point into CHARPRINT, which preserves
    DE. Note that CHARPRINT will load DE with the DO DCB.
- disasm:
    nbytes: 0x0087
    addr: 0x033a
- comment: |+
    =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
    Output character to a device, device control block is pointed to
    by DE, which is eventually transferred into IX. IX+1 -> L, IX + 2 -> H
    which is the device's output function. 0x3dd is also pushed onto
    the stack so that when the output function returns, registers are
    restored.

    Stack looks like:
      BC
      HL
      IX
      DE

    On entry, A has the character to be output. When control is transferred
    to the DCB's function, C has the character to be output.
    =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=

     _______________________________________
    | | | | | | | | |      |         |      |
    |    T Y P E    |VECTOR| SYSDATA | NAME |
    |_|_|_|_|_|_|_|_|______|_________|______|
     7 6 5 4 3 2 1 0 15   0 23      0 15   0

    The DCB follows a strict format that defines the utilization  of all four
    fields.  The  programmer  need  be  concerned only  with the TYPE  and  VECTOR
    fields.  The  system requires sole use of the SYSDATA field. It also maintains
    the NAME field thus usually necessitating no programmer intervention. The  DCB
    format must be followed in all Device Control Blocks established by  the user.
    The following information provides specifications for each field of the DCB.

    TYPE Field - <Byte 0>
    ---------------------

        Bit 7  => This bit specifies that the Control Block is actually a
                  File Control Block (FCB) with the file in an OPEN
                  condition. Since there is a great deal of similarity
                  between DCBs and FCBs, and devices may be routed to
                  files, tracing a path through a device chain may reveal
                  a "device" with this bit set, indicating a routing to a
                  file.

        Bit 6  => This bit specifies that the DCB is associated with a
                  FILTER module. The VECTOR field then contains the entry
                  point of the filter. A filter initializer must set this
                  bit when the module is assigned to the DCB.

        Bit 5  => This bit specifies that the DCB (say device AA) is linked
                  to another device associated with a DCB (say device BB).
                  The VECTOR field of AA will point to a dummy LINK DCB (say
                  device LK) which was established by the system when the
                  LINK library command was invoked. The VECTOR field of LK
                  then will point to the original VECTOR contents of AA
                  while the SYSDATA field will contain a pointer to the BB
                  DCB. A picture is said to be worth a thousand words. The
                  device chain linkage will be illustrated later.

        Bit 4  => This bit specifies that the device defined by the DCB is
                  routed to another character-oriented device or file. The
                  VECTOR field will either point to a DCB if the route
                  destination is a device or it will contain a pointer to
                  the file''s FCB field contained in the route module
                  established by the system''s ROUTE library command.

        Bit 3  => This bit specifies that the device defined by the DCB is
                  a NIL device. Any output directed to the device will be
                  discarded. Any input request will be satisfied with a
                  ZERO return condition.

        Bit 2  => This bit specifies that the device defined by the DCB is
                  capable of handling requests generated by the @CTL Super-
                  Visor Call.

        Bit 1  => This bit specifies that the device defined by the DCB is
                  capable of handling output requests which come from the
                  @PUT SuperVisor Call.

        Bit 0  => This bit specifies that the device defined by the DCB is
                  capable of handling requests for input which come from
                  the @GET SuperVisor Call.

    VECTOR Field - <Bytes 1 - 2>
    ----------------------------
    This field initially will contain the address of the driver routine that
    supports the device hardware associated with the DCB.  In the case of
    programmer-installed drivers, the driver initialization code must load the
    driver's entry point into the VECTOR field of its respective
    DCB. Likewise, when a filter module is established (via the SET library
    command), its entry point is placed into the VECTOR field. Once
    established by either the system or the driver/module initialization code
    to point to the module's entry point, the VECTOR field is then maintained
    by the system to effect routing, linking, and filtering.

    SYSDATA Field - <Bytes 3-5>
    ---------------------------
    These three bytes are used by the system for routing and  linking and are
    unavailable for any other purpose.

    NAME Field - <Bytes 6 - 7>
    --------------------------
    Byte 6 of this  field contains the first character  and byte 7 the second
    character of the device specification name.  The system uses  the device  name
    field as a reference in searching the  Device Control Block tables. When a DCB
    is assigned  by the  system during a SET  or ROUTE command,  this  device name
    field  will be loaded by the system with the device specification name  passed
    in  the  command  invocation. Programs requesting a spare DCB  via  the @GTDCB
    SuperVisor Call  (and  a binary ZERO name), are  responsible  for loading this
    name field.

    If the device has been routed  to a file and a search of the device chain
    shows a  TYPE byte with bit-7 set,  then  the respective control  block  is a
    FCB.  In this case, byte 6  of the field will contain the  DRIVE number of the
    drive containing the file and  byte  7 will contain  the  Directory Entry Code
    (DEC) of the file.

- disasm:
    nbytes: 0x0020
    addr: 0x03c2
- comment: |+
    =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
    Read the keyboard's memory locations, determining if a key has
    been pressed. The scan starts as KBDLINE0, with the C register
    multiplied by 2 (3801, 3802, 3804, ...) via a rotate left until
    location 3880 is reached.

    Address    |0 0x01|1 0x02|2 0x04|3 0x08|4 0x10|5 0x20|6 0x40|7 0x80|
    -----------+------+------+------+------+------+------+------+-------
    3B01       |A     |B     |C     |D     |E     |F     |G     |      |
    3B02       |H     |I     |J     |K     |L     |M     |N     |O     |
    3B04       |P     |Q     |R     |S     |T     |U     |V     |W     |
    3B08       |X     |Y     |Z     |      |      |      |      |      |
    3B10       |0     |1     |2     |3     |4     |5     |6     |7     |
    3B20       |8     |9     |:     |;     |,     |-     |.     |/     |
    3B40       |ENTER |CLR   |UP-ARW|DN-ARW|L-ARW |R-ARW |SPACE |      |
    3B80       |RTSHFT|LTSHFT|      |      |      |      |      |      |
    -----------+------+------+------+------+------+------+------+-------

    =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
- disasm:
    nbytes: 0x0074
    addr: 0x03e3
- comment: |+
    =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
    DO (display output) DCB function

    C has the character to be output on entry.
    (IX + 3), (IX + 4): Current memory location in VIDRAM where the
    character is output (DCB SYSINFO bytes 1 and 2).
    (IX + 5): If non-zero, don''t actually output the character, but
    do the rest of the character processing.
    =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
- disasm:
    nbytes: 0x0134
    addr: 0x0458
- comment: =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
- comment: PR (line printer output) DCB function
- comment: =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
- disasm:
    nbytes: 0x00e6
    addr: 0x058d
- comment: =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
- comment: Initialize the restart vector table, located at RST08VEC
- comment: =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
- disasm:
    nbytes: 0x005d
    addr: 0x0674
- comment: =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
- comment: Restart vector initialization table. Yes, this is code that is
- comment: copied into RAM.
- comment: =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
- comment: 0x4000 -> RST08 redirect
- disasm:
    nbytes: 0x0002
    addr: 0x06d2
- comment: 0x4003 -> RST10 redirect
- disasm:
    nbytes: 0x0002
    addr: 0x06d5
- comment: 0x4006 -> RST18 redirect
- disasm:
    nbytes: 0x0002
    addr: 0x06d8
- comment: 0x4009 -> RST20 redirect
- disasm:
    nbytes: 0x0002
    addr: 0x06db
- comment: 0x400c -> RST28 redirect
- disasm:
    nbytes: 0x0002
    addr: 0x06de
- comment: 0x400f -> RST30 redirect
- disasm:
    nbytes: 0x0002
    addr: 0x06e1
- comment: 0x4012 -> RST38 redirect
- disasm:
    nbytes: 0x0002
    addr: 0x06e4
- comment: ! '0x4015: KI (keyboard) device control block'
- bytes:
    nbytes: 0x0001
    addr: 0x06e7
- jumptable:
    nbytes: 0x0002
    addr: 0x06e8
- bytes:
    nbytes: 0x0003
    addr: 0x06ea
- ascii:
    nbytes: 0x0002
    addr: 0x06ed
- comment: ! '0x401d: DO (display output) device control block'
- bytes:
    nbytes: 0x0001
    addr: 0x06ef
- jumptable:
    nbytes: 0x0002
    addr: 0x06f0
- bytes:
    nbytes: 0x0003
    addr: 0x06f2
- ascii:
    nbytes: 0x0002
    addr: 0x06f5
- comment: ! '0x4025: PR (line printer output) device control block'
- bytes:
    nbytes: 0x0001
    addr: 0x06f7
- jumptable:
    nbytes: 0x0002
    addr: 0x06f8
- bytes:
    nbytes: 0x0003
    addr: 0x06fa
- ascii:
    nbytes: 0x0002
    addr: 0x06fd
- comment: ! '0x402d:'
- disasm:
    nbytes: 0x0005
    addr: 0x06ff
- comment: ! '0x4033: OUTDCB jumps here if the requested device type bit doesn''t
    match'
- disasm:
    nbytes: 0x0002
    addr: 0x0705
- comment: =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
- comment: End of the restart vector initialization table.
- comment: =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
- disasm:
    nbytes: 0x0279
    addr: 0x0708
- comment: =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
- comment: Negate a SP or DP floating point number in ACC/DACC
- comment: =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
- disasm:
    nbytes: 0x003f
    addr: 0x0982
- comment: =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
- comment: Copy bytes from (HL) into BC and DE. Used to load ACC into BC/DE
- comment: for SP floating point routines.
- comment: =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
- disasm:
    nbytes: 0x000f
    addr: 0x09c2
- comment: =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
- comment: Copy bytes pointed to by HL to the buffer pointed to by DE
- comment: This just exchanges DE and HL, falls through to CPDE2HL
- comment: =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
- disasm:
    nbytes: 0x0000
    addr: 0x09d2
- comment: =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
- comment: Copy the bytes pointed to by DE to the buffer pointed to by HL
- comment: A, B, DE and HL are not preserved. NTF (numeric type flag)
- comment: indicates the number of bytes to copy.
- comment: =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
- disasm:
    nbytes: 0x09a8
    addr: 0x09d3
- comment: 0.0 floating point constant
- bytes:
    nbytes: 0x0004
    addr: 0x137c
- comment: 0.5 floating point constant
- bytes:
    nbytes: 0x0004
    addr: 0x1380
- comment: ?? floating point constant
- bytes:
    nbytes: 0x0004
    addr: 0x1384
- disasm:
    nbytes: 0x0202
    addr: 0x1388
- comment: ! 'PI/2: Exploit''s the identity that cos(theta + pi/2) = sin(theta)'
- bytes:
    nbytes: 0x0004
    addr: 0x158b
- comment: ??Floating point constant?
- bytes:
    nbytes: 0x0004
    addr: 0x158f
- comment: Floating point constant?
- bytes:
    nbytes: 0x0004
    addr: 0x1593
- disasm:
    nbytes: 0x00b8
    addr: 0x1597
- comment: =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
- comment: BASIC verb table -- first character has high bit set
- comment: =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
- highbits:
    nbytes: 0x01d0
    addr: 0x1650
- jumptable:
    nbytes: 0x00a9
    addr: 0x1820
- comment: =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
- comment: ! 'BASIC error codes:'
- comment: =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
- ascii:
    nbytes: 0x0002
    addr: 0x18c9
- ascii:
    nbytes: 0x0002
    addr: 0x18cb
- ascii:
    nbytes: 0x0002
    addr: 0x18cd
- ascii:
    nbytes: 0x0002
    addr: 0x18cf
- ascii:
    nbytes: 0x0002
    addr: 0x18d1
- ascii:
    nbytes: 0x0002
    addr: 0x18d3
- ascii:
    nbytes: 0x0002
    addr: 0x18d5
- ascii:
    nbytes: 0x0002
    addr: 0x18d7
- ascii:
    nbytes: 0x0002
    addr: 0x18d9
- ascii:
    nbytes: 0x0002
    addr: 0x18db
- ascii:
    nbytes: 0x0002
    addr: 0x18dd
- ascii:
    nbytes: 0x0002
    addr: 0x18df
- ascii:
    nbytes: 0x0002
    addr: 0x18e1
- ascii:
    nbytes: 0x0002
    addr: 0x18e3
- ascii:
    nbytes: 0x0002
    addr: 0x18e5
- ascii:
    nbytes: 0x0002
    addr: 0x18e7
- ascii:
    nbytes: 0x0002
    addr: 0x18e9
- ascii:
    nbytes: 0x0002
    addr: 0x18eb
- ascii:
    nbytes: 0x0002
    addr: 0x18ed
- ascii:
    nbytes: 0x0002
    addr: 0x18ef
- ascii:
    nbytes: 0x0002
    addr: 0x18f1
- ascii:
    nbytes: 0x0002
    addr: 0x18f3
- ascii:
    nbytes: 0x0002
    addr: 0x18f5
- comment: =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
- comment: BASIC reserved data table.
- comment: =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
- bytes:
    nbytes: 0x0027
    addr: 0x18f7
- ascii:
    nbytes: 0x0005
    addr: 0x191e
- bytes:
    nbytes: 0x0001
    addr: 0x1923
- ascii:
    nbytes: 0x0004
    addr: 0x1924
- bytes:
    nbytes: 0x0001
    addr: 0x1928
- ascii:
    nbytes: 0x0005
    addr: 0x1929
- bytes:
    nbytes: 0x0002
    addr: 0x192e
- ascii:
    nbytes: 0x0005
    addr: 0x1930
- bytes:
    nbytes: 0x0001
    addr: 0x1935
- disasm:
    nbytes: 0x035f
    addr: 0x1936
- comment: =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
- comment: Compare (HL) against character following the RST 08 instruction.
- comment: ''
- comment: Return address is pointed to by SP, which is transferred into HL
- comment: The return address is incremented so that the RET returns to the
- comment: instruction following the character.
- comment: ''
- comment: A is not preserved. (HL) is the character pointed to by the HL
- comment: register.
- comment: =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
- disasm:
    nbytes: 0x04e1
    addr: 0x1c96
- asciiz: 8568
- disasm:
    nbytes: 0x0106
    addr: 0x217f
- asciiz: 8838
- disasm:
    nbytes: 0x0342
    addr: 0x2296
- comment: =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
- comment: Test the numeric type flag (NTF)
- comment: ! 'Z: String'
- comment: ! 'M: Integer'
- comment: ! 'P, C: Single precision'
- comment: P, NC, Double precision
- comment: =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
- disasm:
    nbytes: 0x0a26
    addr: 0x25d9
- symbols:
    RST00: 0x0000
    RST08: 0x0008
    RST10: 0x0010
    WANTDCBGET: 0x0013
    RST18: 0x0018
    WANTDCBPUT: 0x001b
    RST20: 0x0020
    RST28: 0x0028
    KBDSCN: 0x002b
    RST30: 0x0030
    CHARPRINT: 0x0033
    RST38: 0x0038
    LPRINTCHAR: 0x003b
    KBLINE: 0x0040
    KBWAIT: 0x0049
    CTRLCHARS: 0x0050
    DELAY: 0x0060
    NMI_RESET: 0x0066
    HAVEDISK: 0x0069
    L2INIRESRVD: 0x0075
    SETIOB: 0x008b
    L2INIT2: 0x0091
    MEMSIZE: 0x0105
    L2LOGO: 0x0111
    L3ERROR: 0x012d
    CMDPOINT: 0x0132
    BASSET: 0x0135
    BASRESET: 0x0138
    GRSTART: 0x0150
    CLS: 0x01c9
    BASRANDOM: 0x01d3
    CASSPULSE1: 0x01d9
    CASSDLY1: 0x01df
    CASSPULSE2: 0x01e3
    CASSDLY2: 0x01e9
    CASSPULSE3: 0x01ed
    CASSDLY3: 0x01f3
    CASSOFF: 0x01f8
    COUT: 0x033a
    OUTDCB: 0x03c2
    OUTDCBFINISH: 0x03dd
    KBDREAD: 0x03e3
    NXTKEYLINE: 0x03eb
    DODCBFN: 0x0458
    REGCHAR: 0x0480
    CURCON: 0x0506
    PRDCBFN: 0x058d
    LPREADY: 0x05d1
    DOKBLINE: 0x05d9
    INITRSTVECS: 0x0674
    RSTVECTABLE: 0x06d2
    HADD_SPHALF: 0x0708
    SPADD_IND_HL: 0x070b
    SPSUB_IND_HL: 0x0710
    SPSUB_BCDE: 0x0713
    SPADD_BCDE: 0x0716
    SPMUL_BCDE: 0x0847
    SPDIV_BCDE: 0x08a2
    NEG_MANTISSA: 0x0982
    BCDE_VIA_HL: 0x09c2
    CPHL2DE: 0x09d2
    CPDE2HL: 0x09d3
    # Integer math functions
    INTADD: 0x0bd2
    INTSUB: 0x0bc7
    INTMPY: 0x0bf2
    # Floating point constants
    SFPZERO: 0x137c
    SFPHALF: 0x1380
    # BASIC trancendental functions
    BASCOS: 0x1541
    BASSIN: 0x1547
    PI_OVER_2: 0x158b
    BASTAN: 0x15a8
    BASATN: 0x15bd
    # BASIC's high-bit verb table
    VERBS: 0x1650
    VERBDISPATCH: 0x1822
    # BASIC's error strings
    ERRNOFOR: 0x18c9
    ERRSYNTAX: 0x18cb
    ERRRANGE: 0x18cd
    ERROUTOFDATA: 0x18cf
    ERRBADFUNC: 0x18d1
    ERROVERFLOW: 0x18d3
    ERROUTOFMEM: 0x18d5
    ERRUNDEFLINE: 0x18d7
    ERRBADSUBSCR: 0x18d9
    ERRBADDIM: 0x18db
    ERRDIV0: 0x18dd
    ERRILLEGALDIRECT: 0x18df
    ERRTYPEMISMATCH: 0x18e1
    ERRNOSTRSPACE: 0x18e3
    ERRLONGSTRING: 0x18e5
    ERRCOMPLEXSTR: 0x18e7
    ERRNOCONT: 0x18e9
    ERRNORESUME: 0x18eb
    ERRRESUMENOERR: 0x18ed
    ERRUNPRINTERR: 0x18ef
    ERRMISSOPERAND: 0x18f1
    ERRFILEDATA: 0x18f3
    ERRL3DOS: 0x18f5
    BASRSVINIT: 0x18f7
    READYPMT: 0x1929
    BREAKMSG: 0x1930
    ERORORIN: 0x191d
    CMPDEHL: 0x1c90
    DEFRST08: 0x1c96
    BASFOR: 0x1ca1
    DEFRST10: 0x1d78
    BASRESTORE: 0x1d91
    BASEND: 0x1dae
    BASSTOP: 0x1da9
    BASTRON: 0x1df7
    BASTROFF: 0x1df8
    BASGOSUB: 0x1eb1
    BASRETURN: 0x1ede
    BASGOTO: 0x1ec2
    BASRUN: 0x1ea3
    BASDATA: 0x1f05
    BASREM: 0x1f07
    BASLET: 0x1f21
    BASIF: 0x2039
    BASINPUT: 0x219a
    BASREAD: 0x21ef
    BASNEXT: 0x22b6
    INTDIV: 0x2490
    NUMTYPE: 0x25d9
    BASDIM: 0x2608
...
