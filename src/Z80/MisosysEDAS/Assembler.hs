{-# LANGUAGE CPP #-}

module Z80.MisosysEDAS.Assembler 
  ( -- * Types and Data Constructors
    EDASAsmOutput

    -- * Functions
  , edasAssemble
  , evalAsmExpr
  , evalAsmExprWord8
  ) where

-- import Debug.Trace

#ifdef mingw32_HOST_OS
import Control.Lens hiding (value, op)
#else
import Control.Lens hiding (value)
#endif

import Control.Monad
import Data.Either
import Data.Word
import Data.Int
import Data.List
import Data.Bits
import Text.Parsec.Pos
import qualified Data.Char as C
import qualified Data.Map as Map
import qualified Data.Text as T
import qualified Data.Vector.Unboxed as DVU

import Machine.Utils
import Z80.Processor
import Z80.MisosysEDAS.Types

-- | Shorthand for catching intermediate assembler issues and problems
type IntermediateCtx = Either T.Text AsmEvalCtx

-- | Shorthand for the assembler's final result
type EDASAsmOutput = Either T.Text (AsmEvalCtx, [AsmStmt])

-- | The assembler pass: Evaluate the pseudo-operations and expressions within instructions, update the assembler
-- statement with the results and 'Z80instruction's.
edasAssemble :: Either T.Text [AsmStmt]                 -- ^ Parser result
             -> EDASAsmOutput                           -- ^ Assembler result
edasAssemble parseResult =
  case parseResult of
    Left stuff   -> Left stuff
    Right  stmts -> let initialCtx = Right $ AsmEvalCtx { _symbolTab = Map.empty
                                                        , _asmPC     = 0
                                                        }
                        (finalctx, result) = mapAccumL evalAsmStmt initialCtx stmts
                    in  case finalctx of
                          Left stuff   -> Left stuff
                          Right  ctx   -> Right (ctx, result)

-- | Evaluate a single assembler statement
evalAsmStmt :: IntermediateCtx
            -> AsmStmt
            -> (IntermediateCtx, AsmStmt)
evalAsmStmt ictx stmt =
  case ictx of
    Left stuff  -> (Left stuff, stmt)
    Right ctx   -> case stmt ^. asmOp of
                     Nothing              -> (Right ctx, stmt)
                     Just (Insn insn)     -> (Right ctx, stmt)
                     Just (Pseudo pseudo) -> evalPseudo ctx stmt pseudo

evalPseudo :: AsmEvalCtx
           -> AsmStmt
           -> EDASPseudo
           -> (IntermediateCtx, AsmStmt)
evalPseudo ctx stmt pseudo =
    case pseudo of
      Equate expr    -> (evalEquate (stmt ^. symLabel) expr ctx, stmt)
      Origin org     -> (liftM (\o -> asmPC .~ o $ ctx) (evalAsmExpr ctx org), stmt)
      DefB args      -> evalDefB args ctx stmt
      DefC rept fill -> evalDefC rept fill ctx stmt

-- | Evaluate a symbol equate
evalEquate :: Maybe EDASLabel
           -> EDASExpr
           -> AsmEvalCtx
           -> IntermediateCtx
evalEquate Nothing    _    _   = Left "Equate is missing symbol to which to assign result."
evalEquate (Just sym) expr ctx = liftM (insertAsmSymbol ctx sym) (evalAsmExpr ctx expr)

-- | Evaluate the "db"/"defb" argument list and fold the generated bytes into the assembler statement
evalDefB :: [DBValue]
         -> AsmEvalCtx
         -> AsmStmt
         -> (IntermediateCtx, AsmStmt)
evalDefB args ctx stmt =
        let (ls, rs)                 = partitionEithers $ map cvtDBValue args
            theBytes                 = DVU.concat $ map DVU.fromList rs
            currentPC                = ctx ^. asmPC
            cvtDBValue (DBStr str)   = Right $ map (fromIntegral . C.ord) $ T.unpack str
            cvtDBValue (DBExpr expr) = liftM (: []) (evalAsmExprWord8 ctx expr)
        in  if (not . null) ls then
              -- Only report the first error
              (Left $ head ls, stmt)
            else
              -- No error: move the program counter forward, save the bytes generated
              ( Right $ (asmPC %~ (+ (fromIntegral . DVU.length) theBytes)) $ ctx
              , stmtAddr .~ currentPC $ bytes .~ theBytes $ stmt
              )

-- | Define constant fill/block
evalDefC :: EDASExpr
         -> EDASExpr
         -> AsmEvalCtx
         -> AsmStmt
         -> (IntermediateCtx, AsmStmt)
evalDefC rept fill ctx stmt =
  let reptVal = evalAsmExpr ctx rept
      fillVal = evalAsmExprWord8 ctx fill
      currentPC = ctx ^. asmPC
  in  case reptVal of
        Left reptErr -> (Left reptErr, stmt)
        Right rval   -> case fillVal of
                          Left fillErr -> (Left fillErr, stmt)
                          Right fval   -> let theBytes = DVU.replicate (fromIntegral rval) fval
                                          in  ( Right $ (asmPC %~ (+ (fromIntegral . DVU.length) theBytes) $ ctx)
                                              , stmtAddr .~ currentPC $ bytes .~ theBytes $ stmt
                                              )

-- | Evaluate an assembler expression to produce a 'Word16' result, within the current assembler evaluation context
evalAsmExpr :: AsmEvalCtx
            -> EDASExpr
            -> Either T.Text Word16
evalAsmExpr _ctx (Const _srcloc cst) = Right (fromIntegral cst)
evalAsmExpr  ctx (Var pos v)         = case findAsmSymbol ctx v of
                                         Nothing -> Left (T.concat [ mkSourcePosT pos
                                                                   , "Unknown equate or label name: "
                                                                   , v
                                                                   ]
                                                         )
                                         Just x  -> Right x
evalAsmExpr _ctx (AsmChar c)         = Right ((fromIntegral . C.ord) c)
evalAsmExpr ctx  (Add l r)           = evalBinOp ctx (+) l r
evalAsmExpr ctx  (Sub l r)           = evalBinOp ctx (-) l r
evalAsmExpr ctx  (Mul l r)           = evalBinOp ctx (*) l r
evalAsmExpr ctx  (Div l r)           = liftM2 (\l' r' -> l' `div` (r' .&. 0xff)) (evalAsmExpr ctx l) (evalAsmExpr ctx r)
evalAsmExpr ctx  (Mod l r)           = liftM2 (\l' r' -> l' `mod` (r' .&. 0xff)) (evalAsmExpr ctx l) (evalAsmExpr ctx r)
evalAsmExpr ctx  (Shift v x)         = liftM2 (\v' x' -> let x'' = (fromIntegral x') :: Int16
                                                         in  v' `shift` (fromIntegral x''))
                                              (evalAsmExpr ctx v)
                                              (evalAsmExpr ctx x)
evalAsmExpr ctx  (LogAnd l r)        = evalBinOp ctx (.&.) l r
evalAsmExpr ctx  (LogOr  l r)        = evalBinOp ctx (.|.) l r
evalAsmExpr ctx  (LogXor l r)        = evalBinOp ctx xor l r
evalAsmExpr ctx  (LogNE  l r)        = evalCompare ctx (/=) l r
evalAsmExpr ctx  (LogEQ  l r)        = evalCompare ctx (==) l r
evalAsmExpr ctx  (LogGE  l r)        = evalCompare ctx (>=) l r
evalAsmExpr ctx  (LogGT  l r)        = evalCompare ctx (>)  l r
evalAsmExpr ctx  (LogLE  l r)        = evalCompare ctx (<=) l r
evalAsmExpr ctx  (LogLT  l r)        = evalCompare ctx (<)  l r
evalAsmExpr ctx  (ShiftL v x)        = liftM2 (\v' x' -> v' `shiftL` (fromIntegral x')) (evalAsmExpr ctx v) (evalAsmExpr ctx x)
evalAsmExpr ctx  (ShiftR v x)        = liftM2 (\v' x' -> v' `shiftR` (fromIntegral x')) (evalAsmExpr ctx v) (evalAsmExpr ctx x)
evalAsmExpr ctx  (OnesCpl x)         = evalUnaryOp ctx complement x
evalAsmExpr ctx  (HighByte x)        = evalUnaryOp ctx (\y -> (y `shiftR` 8) .&. 0xff) x
evalAsmExpr ctx  (LowByte x)         = evalUnaryOp ctx (\y -> y .&. 0xff) x

-- | Evaluate a unary operator expression
evalUnaryOp :: AsmEvalCtx
            -> (Word16 -> Word16)
            -> EDASExpr
            -> Either T.Text Word16
evalUnaryOp ctx op x = liftM op (evalAsmExpr ctx x)

-- | Evaluate a binary operator expression
evalBinOp :: AsmEvalCtx
          -> (Word16 -> Word16 -> Word16)
          -> EDASExpr
          -> EDASExpr
          -> Either T.Text Word16
evalBinOp ctx op l r = liftM2 op (evalAsmExpr ctx l) (evalAsmExpr ctx r)

-- | Evaluate a comparison expression
evalCompare :: AsmEvalCtx
            -> (Word16 -> Word16 -> Bool)
            -> EDASExpr
            -> EDASExpr
            -> Either T.Text Word16
evalCompare ctx op l r = liftM2 compareResult (evalAsmExpr ctx l) (evalAsmExpr ctx r)
  where
    compareResult l' r' = if l' `op` r' then
                          0 :: Word16
                        else
                          0xffff :: Word16

-- | Evaluate an assembler expression to produce a 'Word8' result, within the current assembler evaluation context
evalAsmExprWord8 :: AsmEvalCtx
                 -> EDASExpr
                 -> Either T.Text Z80word
evalAsmExprWord8 ctx expr = rangeCheck (evalAsmExpr ctx expr)
  where
    rangeCheck (Left  x) = Left x
    rangeCheck (Right x) = if (x .&. 0xff00 == 0xff00) || (x <= 0xff) then
                             Right $ fromIntegral (x .&. 0xff)
                           else
                             Left (T.concat [ "value out of range for 8-bit value: "
                                            , (T.pack . show) x
                                            , "("
                                            , (as0xHex x)
                                            , ")"
                                            ]
                                  )

-- | Utility function for outputting the source position
mkSourcePosT :: SourcePos
             -> T.Text
mkSourcePosT srcpos = T.concat [ (T.pack . sourceName) srcpos
                               , ", line "
                               , (T.pack . show . sourceLine) srcpos
                               , ", col "
                               , (T.pack . show . sourceColumn) srcpos
                               , ": "
                               ]
