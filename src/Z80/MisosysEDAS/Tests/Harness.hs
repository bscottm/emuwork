-- | Test harness for the Misosys EDAS-compatible assembler.
module Main where

import Prelude hiding (pred)

-- import Debug.Trace

import Test.HUnit
import Data.Maybe
import Data.Word
import Data.Bits
import Data.List
import Control.Lens
import Control.Monad
import qualified Data.Char as C
import qualified Data.Text as T
import qualified Data.Vector.Unboxed as DVU

import Z80
import Z80.MisosysEDAS

main :: IO ()
main = runTestTT edasTests
       >> return ()

infix 1 @!?

-- | Boolean false assertion: Expect that the result of the test will be 'False'.
(@!?) :: (AssertionPredicable t) =>
         t
      -> String
      -> Assertion
pred @!? msg = assertionPredicate pred >>= (\b -> when b (assertFailure msg))

-- | The list of tests that 'HUnit' will execute.
edasTests :: Test
edasTests = test [ defbTests
                 , defcTests
                 , defsTests
                 , defwTests
                 , dateTimeTest
                 , dsymTests
                 , equateTests
                 ]

-- | "Assembler pass failed" error message
asmPassFailed :: String
asmPassFailed = "Assembler pass failed"
-- | "Byte vector mismatch" error message
byteVecMismatch :: String
byteVecMismatch = "Byte vector mismatch" :: String
-- | "Expected lengths/program counters don't match" error message
progCtrsMismatch :: String
progCtrsMismatch = "Program counters or expected byte vector length don't match" :: String

-- | "DB"/"DEFB" (define bytes) tests. Ensures that code will assemble correctly, generated byte vectors are correct,
-- and with the proper lengths.
defbTests :: Test
defbTests = test [ "defb"              ~: (checkAssembly defbAsm)                                   @? asmPassFailed
                 , "defbExpected"      ~: (checkByteVectors and defbAsm defbExpected)               @? byteVecMismatch
                 , "defbProgCtrs"      ~: (checkProgramCounters and defbAsm defbProgCtrs)           @? progCtrsMismatch
                 , "edasManDB"         ~: (checkAssembly edasManDBAsm)                              @? asmPassFailed
                 , "edasManDBExpected" ~: (checkByteVectors and edasManDBAsm edasManDBExpected)     @? byteVecMismatch
                 , "defbProgCtrs"      ~: (checkProgramCounters and edasManDBAsm edasManDBProgCtrs) @? progCtrsMismatch
                 ]
  where
    defbSource = T.intercalate "\n" [ "                DB       00h"
                                    , "                defb     0, 1"
                                    , "                defb     0,1"
                                    , "                DB       00h, 01h, 'c'"
                                    , "                DEFB     'Memory size?'"
                                    , "                db       'Mem ''sz''?'"
                                    ]
    defbExpected = [ DVU.singleton 0
                   , DVU.fromList [0, 1]
                   , DVU.fromList [0, 1]
                   , DVU.fromList [0, 1, charToWord8 'c']
                   , DVU.fromList (textToWord8 "Memory size?")
                   , DVU.fromList (textToWord8 "Mem \'sz\'?")
                   ]

    (_finalPC, defbProgCtrs) = generateExpectedStmtAddresses 0 defbExpected

    -- Parse and assemble the source:
    defbAsm = edasAssemble $ edasParseSequence "defbSource" defbSource

    -- Test case from the EDAS manual:
    edasManDBSrc = T.intercalate "\n" [ "               DB    'This',' ','is',' ','a',' ','test'"
                                      , "               DB    1,2,'buckle your shoe',3,4,'close the door'"
                                      , "               DB    'This is a tes','t'!80H"
                                      ]
    edasManDBExpected = [ DVU.fromList (textToWord8 "This is a test")
                        , DVU.fromList ( [ 1, 2 ]
                                         ++ (textToWord8 "buckle your shoe")
                                         ++ [ 3, 4 ]
                                         ++ (textToWord8 "close the door")
                                       )
                        , DVU.concat [ DVU.fromList (textToWord8 "This is a tes")
                                     , DVU.singleton (((fromIntegral . C.ord) 't') .|. 0x80)
                                     ]
                        ]
    (_finalPC2, edasManDBProgCtrs) = generateExpectedStmtAddresses 0 edasManDBExpected

    edasManDBAsm = edasAssemble $ edasParseSequence "edasManDB" edasManDBSrc

-- | "DC" (define constant space/fill) tests. See 'defbTests' for what is checked.
defcTests :: Test
defcTests = test [ "defc"              ~: (checkAssembly defcAsm)                         @? asmPassFailed
                 , "defcExpected"      ~: (checkByteVectors and defcAsm defcExpected)     @? byteVecMismatch
                 , "defcProgCtrs"      ~: (checkProgramCounters and defcAsm defcProgCtrs) @? progCtrsMismatch
                 ]
  where
    defcSource = T.intercalate "\n" [ "                Dc       16, 00h"
                                    , "                dC       17, -1"
                                    , "                DC       37, 'A'"
                                    , "                DC       256, 'a' !80H"
                                    ]

    defcExpected = [ DVU.replicate 16 0
                   , DVU.replicate 17 0xff
                   , DVU.replicate 37 ((fromIntegral . C.ord) 'A')
                   , DVU.replicate 256 (((fromIntegral . C.ord) 'a') .|. 0x80)
                   ] :: [(DVU.Vector Z80word)]

    (_finalPC, defcProgCtrs) = generateExpectedStmtAddresses 0 defcExpected

    -- Parse and assemble the source:
    defcAsm = edasAssemble $ edasParseSequence "defcSource" defcSource

-- | "DS" (define space) tests -- "DS" is essentially the same as "DC" with a fill constant of 0.
defsTests :: Test
defsTests = test [ "defs"              ~: (checkAssembly defsAsm)                         @? asmPassFailed
                 , "defsExpected"      ~: (checkByteVectors and defsAsm defsExpected)     @? byteVecMismatch
                 , "defsProgCtrs"      ~: (checkProgramCounters and defsAsm defsProgCtrs) @? progCtrsMismatch
                 ]
  where
    defsSource = T.intercalate "\n" [ "                Ds       16"
                                    , "                dS       17"
                                    , "                DS       37"
                                    , "                DS       256"
                                    ]

    defsExpected = [ DVU.replicate 16 0
                   , DVU.replicate 17 0
                   , DVU.replicate 37 0
                   , DVU.replicate 256 0
                   ] :: [(DVU.Vector Z80word)]

    (_finalPC, defsProgCtrs) = generateExpectedStmtAddresses 0 defsExpected

    -- Parse and assemble the source:
    defsAsm = edasAssemble $ edasParseSequence "defsSource" defsSource

-- | "DW"/"DEFW" (define words). Note that the Z80 is a little endian architecture.
defwTests :: Test
defwTests = test [ "defw"              ~: (checkAssembly defwAsm)                         @? asmPassFailed
                 , "defwExpected"      ~: (checkByteVectors and defwAsm defwExpected)     @? byteVecMismatch
                 , "defwProgCtrs"      ~: (checkProgramCounters and defwAsm defwProgCtrs) @? progCtrsMismatch
                 ]
  where
    defwSource = T.intercalate "\n" [ "                Dw       'R', 'o','y'"
                                    , "                dW       'ab'"
                                    , "                DW       10000,1000,100,10,1"
                                    ]

    defwExpected = [ DVU.fromList [ charToWord8 'R', 0, charToWord8 'o', 0, charToWord8 'y', 0 ]
                   , DVU.fromList [ charToWord8 'a', charToWord8 'b' ]
                   , DVU.fromList [ low 10000, high 10000
                                  , low 1000,  high 1000
                                  , low 100,   high 100
                                  , low 10,    high 10
                                  , low 1,     high 1
                                  ]
                   ] :: [(DVU.Vector Z80word)]

    high, low :: Word16 -> Word8
    high x = fromIntegral (x `shiftR` 8)
    low  x = fromIntegral (x .&. 0xff)

    (_finalPC, defwProgCtrs) = generateExpectedStmtAddresses 0 defwExpected

    -- Parse and assemble the source:
    defwAsm = edasAssemble $ edasParseSequence "defwSource" defwSource

-- | "DATE" and "TIME" pseudo-operation tests. This cannot check the exact date/time that's generated; however,
-- this test just ensures that something sensible is generated.
dateTimeTest :: Test
dateTimeTest = test [ "datetimeAsm"       ~: (checkAssembly dateTimeAsm)                     @? asmPassFailed
                    , "datetimeProgCtrs"  ~: (checkProgramCounters and dateTimeAsm progCtrs) @? progCtrsMismatch
                    ]
  where
    theSource   = T.intercalate "\n" [ "                DATE"
                                     , "                TIME"
                                     , "                TIME"
                                     ]

    -- For the new-to-Haskell: Since Haskell is really lazy, '(progCtrs !! 1)' will not be evaluated until it is
    -- actually needed, i.e., until 'checkProgramCounters' actually needs the value of 'progCtrs !! 1', which
    -- requires that the second element of the list (index 1) be evaluated at that time as well. Hence, it's a
    -- legitimate expression.
    progCtrs     = [ 0
                   , (fromIntegral . T.length) "MM/DD/YY"
                   , (progCtrs !! 1) + (fromIntegral . T.length) "HH:MM:SS"
                   ] :: [Z80addr]

    dateTimeAsm = edasAssemble $ edasParseSequence "dateTimeTestSource" theSource

-- | "DSYM" and "DX" tests.
dsymTests :: Test
dsymTests = test [ "dsym"              ~: (checkAssembly dsymAsm)                         @? asmPassFailed
                 , "dsymExpected"      ~: (checkByteVectors and dsymAsm dsymExpected)     @? byteVecMismatch
                 , "dsymProgCtrs"      ~: (checkProgramCounters and dsymAsm dsymProgCtrs) @? progCtrsMismatch
                 ]
  where
    dsymSource = T.intercalate "\n" [ "         ORG     0E143H"
                                    , "LABEL:"
                                    , "         DSYM    LABEL"
                                    , "         DX      LABEL"
                                    ]

    dsymExpected = [ DVU.empty
                   , DVU.empty
                   , DVU.fromList $ textToWord8 "LABEL"
                   , DVU.fromList [ 0x43, 0xe1 ]
                   ] :: [(DVU.Vector Z80word)]

    dsymProgCtrs = [ 0
                   , 0xe143
                   , (dsymProgCtrs !! 1) + (fromIntegral . DVU.length) (dsymExpected !! 1)
                   , (dsymProgCtrs !! 2) + (fromIntegral . DVU.length) (dsymExpected !! 2)
                   ]

    -- Parse and assemble the source:
    dsymAsm = edasAssemble $ edasParseSequence "dsymSource" dsymSource


-- | Symbol equate and expression tests. This checks for a successful assembler pass, that the symbols inserted are
-- present, that bad/extraneous/invalid symbols are not in the final symbol table, and checks that expression parsing
-- and evaluation functions correctly. 
--
-- One thing to note about EDAS: it never had a concept of parenthesized expressions or mathematical precedence; evaluation
-- is strictly from left to right.
equateTests :: Test
equateTests = test [ "equateAsm"    ~: (checkAssembly equatesAsm)                           @? asmPassFailed
                   , "equateSyms-1" ~: (checkSymbolsWith and equatesAsm goodSyms)           @? "Symbols missing from symtab"
                   , "equateSyms-2" ~: (liftM not $ checkSymbolsWith or equatesAsm badSyms) @? "Extraneous symbols in symtab"
                   , "equateVals-1" ~: (checkSymbolValuesWith and equatesAsm expectedVals)  @? "Expected evaluation failed"
                   , "primExprAsm"  ~: (checkAssembly primExprAsm)                          @? asmPassFailed
                   , "primExprVals" ~: (checkSymbolValuesWith and primExprAsm primExpected) @? "Expected evaluation failed"
                   ]
  where
    symEquates = T.intercalate "\n" [ "CON30   EQU   30"
                                    , "CON16   EQU   +10H"
                                    , "CON3    EQU   3"
                                    , "A2      EQU   CON30+CON16"
                                    , "A3      equ   con30+con16*4"
                                    ]
    expectedVals = [ ("con30", 30)
                   , ("CoN30", 30)
                   , ("cOn30", 30)
                   , ("con16", 16)
                   , ("CON3",   3)
                   , ("A2",    46)
                   , ("A3",  46*4)                      -- Note lack of operator precedence
                   ]

    -- Parse and assemble the equates
    equatesAsm = edasAssemble $ edasParseSequence "symEquates" symEquates

    -- Symbols that must be present in the final symbol table
    goodSyms = [ "Con30", "CON30", "con30"
               , "CON16", "con16", "cOn16"
               , "CON3",  "Con3"
               , "A2", "a2"
               , "A3", "a3"
               ]

    -- Symbols that will not be present in the final symbol table
    badSyms      = [ "Cno30", "foobar", "frobnats"
                   , "a5", "A5"
                   , "con", "noc"
                   ]

    -- Primary expression testing
    primExpr     = T.intercalate "\n" [ "C1      EQU   .not. 30"
                                      , "C2      EQU   .high. c1"
                                      , "C3      EQU   .low.c1"
                                      , "C4      EQU   .low. c1"
                                      , "C5      EQU   C2.shl.8!c4.EQ.c1"
                                      , "C6      EQU   c2 .shl. 8!c4.eq.c1"
                                      , "C7      EQU   C2.shl.8 ! c4.EQ. C1"
                                      , "C8      EQU   c2<8!C4 .EQ. C1"
                                      , "C9      equ   c1<-8<8!c4 .eq. c1"
                                      ]
    primExpected = [ ("c1", 0xffe1)
                   , ("c2", 0x00ff)
                   , ("c3", 0x00e1)
                   , ("c4", 0x00e1)
                   , ("c5", 0x0000)
                   , ("c6", 0x0000)
                   , ("c7", 0x0000)
                   , ("c8", 0x0000)
                   , ("c9", 0x0000)
                   ] :: [(T.Text, Word16)]

    -- Assembler output for primary expressions
    primExprAsm = edasAssemble $ edasParseSequence "primExpr" primExpr

-- | Check to see if the code assembled correctly.
checkAssembly :: EDASAsmOutput                          -- ^ The assembler's output
              -> IO Bool
checkAssembly asm = liftM checkAsm asm
  where
    checkAsm theAsm = case theAsm of
                        Left problems -> error (T.unpack problems)
                        Right _       -> True

-- | Check the symbols in the final symbol table, according to a predicate, e.g., 'and' ensures that all symbols are present.
checkSymbolsWith :: ([Bool] -> Bool)                    -- ^ Predicate function
                 -> EDASAsmOutput                       -- ^ Assembler output
                 -> [T.Text]                            -- ^ Symbol names
                 -> IO Bool
checkSymbolsWith pred asm syms = liftM checkSyms asm
  where
    checkSyms theAsm = case theAsm of
                         Left problems             -> error (T.unpack problems)
                         Right (finalctx, _result) -> pred $ map (existsAsmSymbol finalctx) syms

-- | Check symbol values with a predicate, e.g., 'and' ensures that all values are correct.
checkSymbolValuesWith :: ([Bool] -> Bool)               -- ^ Predicate function
                      -> EDASAsmOutput                  -- ^ Assembler output
                      -> [(T.Text, Word16)]             -- ^ (symbol name, expected value) list
                      -> IO Bool
checkSymbolValuesWith pred asm syms = liftM checkSVals asm
  where
    checkSVals theAsm = case theAsm of
                          Left problems             -> error (T.unpack problems)
                          Right (finalctx, _result) -> pred $ [ fromMaybe 0 (findAsmSymbol finalctx x) == y | (x, y) <- syms ]

-- | Check the byte vectors with a predicate
checkByteVectors :: ([Bool] -> Bool)                    -- ^ Predicate function that compares expected to actual values
                 -> EDASAsmOutput                       -- ^ The assembler's output
                 -> [(DVU.Vector Word8)]                -- ^ Expected generated bytes
                 -> IO Bool                             -- ^ Test result
checkByteVectors pred asm expected = liftM checkBVecs asm
  where
    checkBVecs theAsm = case theAsm of
                          Left problems            -> error (T.unpack problems)
                          Right (_finalctx, stmts) -> pred $ zipWith (==)
                                                                     (map (\x -> x ^. bytes & DVU.toList) stmts)
                                                                     (map DVU.toList expected)

-- | Check the expected program counter with a predicate
checkProgramCounters :: ([Bool] -> Bool)              -- ^ Predicate function that compares the expected to actual PCs.
                     -> EDASAsmOutput                 -- ^ The assembler's output
                     -> [Z80addr]                     -- ^ Expected program counter values
                     -> IO Bool                       -- ^ Test result
checkProgramCounters pred asm expected = liftM checkPCs asm
  where
    checkPCs theAsm = case theAsm of
                        Left problems            -> error (T.unpack problems)
                        Right (_finalctx, stmts) -> pred $ zipWith (==) (stmtAddrs stmts) expected
    stmtAddrs stmts = map (\x -> x ^. stmtAddr) stmts

-- | Convert a character to 'Word8'
charToWord8 :: Char
            -> Word8
charToWord8 = fromIntegral . C.ord

-- Convert 'String' to a list of 'Word8's
stringToWord8 :: String
              -> [Word8]
stringToWord8 = map charToWord8

-- Convert 'Text' to a list of 'Word8's
textToWord8 :: T.Text
            -> [Word8]
textToWord8 = stringToWord8 . T.unpack

-- | Generate statement addresses from the expected byte vector output
generateExpectedStmtAddresses :: (DVU.Unbox wordType) =>
                                 Z80addr
                              -> [DVU.Vector wordType]
                              -> (Z80addr, [Z80addr])
generateExpectedStmtAddresses origin = mapAccumL (\pc elt -> (pc + (fromIntegral . DVU.length) elt, pc)) origin
